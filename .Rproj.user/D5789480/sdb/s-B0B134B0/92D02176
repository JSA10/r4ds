{
    "collab_server" : "",
    "contents" : "#r4ds wrangle - Relational Data\n\n\n#13 Relational data\n\n#13.1 Introduction\n\"\"\"\nIt’s rare that a data analysis involves only a single table of data. Typically\nyou have many tables of data, and you must combine them to answer the questions\nthat you’re interested in. Collectively, multiple tables of data are called\nrelational data because it is the relations, not just the individual datasets,\nthat are important.\n\nRelations are always defined between a pair of tables. All other relations are\nbuilt up from this simple idea: the relations of three or more tables are always\na property of the relations between each pair. Sometimes both elements of a\npair can be the same table! This is needed if, for example, you have a table of\npeople, and each person has a reference to their parents.\n\nTo work with relational data you need verbs that work with pairs of tables.\nThere are three families of verbs designed to work with relational data:\n\n1. Mutating joins, which add new variables to one data frame from matching\nobservations in another.\n\n2. Filtering joins, which filter observations from one data frame based on\nwhether or not they match an observation in the other table.\n\n3. Set operations, which treat observations as if they were set elements.\n\nThe most common place to find relational data is in a relational database\nmanagement system (or RDBMS), a term that encompasses almost all modern\ndatabases. If you’ve used a database before, you’ve almost certainly used SQL.\nIf so, you should find the concepts in this chapter familiar, although their\nexpression in dplyr is a little different. Generally, dplyr is a little easier\nto use than SQL because dplyr is specialised to do data analysis: it makes\ncommon data analysis operations easier, at the expense of making it more\ndifficult to do other things that aren’t commonly needed for data analysis.\n\"\"\"\n\n#use dplyr to explore relational data from nyc13\n\nlibrary(nycflights13)\n#contains 4 datasets - is related to flights data used in transformation section\n\n#1. airlines lets you look up the full carrier name from its abbreviated code:\n#2. airports gives information about each airport, identified by the faa airport\n# code\n#3. planes gives information about each plane, identified by its tailnum:\n#4. weather gives the weather at each NYC airport for each hour\n\n# visualising relationships in a diagram is useful (can sometimes be daunting)\n\"\"\"\nThe key to understanding diagrams like this is to remember each relation always\nconcerns a pair of tables. You don’t need to understand the whole thing; you\njust need to understand the chain of relations between the tables that you are\ninterested in.\n\nFor nycflights13:\n\nflights connects to planes via a single variable, tailnum.\n\nflights connects to airlines through the carrier variable.\n\nflights connects to airports in two ways: via the origin and dest variables.\n\nflights connects to weather via origin (the location), and year, month, day and\nhour (the time).\n\"\"\"\n\n# 13.2.1 exercises - return if want to understand relational tables conceptually\n# and for more context on nycflights dataset\n\nglimpse(airports)\nairports %>%\n    count(faa) %>%\n    filter(faa == 'EWR')\n\n?count\nglimpse(weather)\n\n\n\n# 13.3 KEYS\n\n# Variables used to connect tables = keys\n# Key = variable or set of variables used to uniquely identify an observation\n# Key can be single variable e.g. tailnum for plane\n# OR multiple variables e.g. year, month, day, hour, and origin used to\n# identify a weather observation\n\n\"\"\"\nThere are two types of keys:\n\nA primary key uniquely identifies an observation in its own table. For example,\nplanes$tailnum is a primary key because it uniquely identifies each plane in\nthe planes table.\n\nA foreign key uniquely identifies an observation in another table. For example,\nthe flights$tailnum is a foreign key because it appears in the flights table\nwhere it matches each flight to a unique plane.\n\nA variable can be both a primary key and a foreign key. For example, origin is\npart of the weather primary key, and is also a foreign key for the airport\ntable.\n\"\"\"\n\n#Once you’ve identified the primary keys in your tables, it’s good practice to\n#verify that they do indeed uniquely identify each observation. One way to do\n#that is to count() the primary keys and look for entries where n is greater\n#than one:\n\nplanes %>%\n    count(tailnum) %>%\n    filter(n > 1)\n#> # A tibble: 0 × 2\n#> # ... with 2 variables: tailnum <chr>, n <int>\n\nweather %>%\n    count(year, month, day, hour, origin) %>%\n    filter(n > 1)\n#> Source: local data frame [0 x 6]\n#> Groups: year, month, day, hour [0]\n#>\n#> # ... with 6 variables: year <dbl>, month <dbl>, day <int>, hour <int>,\n#> #   origin <chr>, n <int>\n\n\"\"\"\nSometimes a table doesn’t have an explicit primary key: each row is an\nobservation, but no combination of variables reliably identifies it. For\nexample, what’s the primary key in the flights table? You might think it would\nbe the date plus the flight or tail number, but neither of those are unique:\n\"\"\"\n\nflights %>%\n    count(year, month, day, flight) %>%\n    filter(n > 1)\n#> Source: local data frame [29,768 x 5]\n#> Groups: year, month, day [365]\n#>\n#>    year month   day flight     n\n#>   <int> <int> <int>  <int> <int>\n#> 1  2013     1     1      1     2\n#> 2  2013     1     1      3     2\n#> 3  2013     1     1      4     2\n#> 4  2013     1     1     11     3\n#> 5  2013     1     1     15     2\n#> 6  2013     1     1     21     2\n#> # ... with 2.976e+04 more rows\n\nflights %>%\n    count(year, month, day, tailnum) %>%\n    filter(n > 1)\n#> Source: local data frame [64,928 x 5]\n#> Groups: year, month, day [365]\n#>\n#>    year month   day tailnum     n\n#>   <int> <int> <int>   <chr> <int>\n#> 1  2013     1     1  N0EGMQ     2\n#> 2  2013     1     1  N11189     2\n#> 3  2013     1     1  N11536     2\n#> 4  2013     1     1  N11544     3\n#> 5  2013     1     1  N11551     2\n#> 6  2013     1     1  N12540     2\n#> # ... with 6.492e+04 more rows\n\n\"\"\"\nIf a table lacks a primary key, it’s sometimes useful to add one with\nmutate() and row_number(). That makes it easier to match observations if\nyou’ve done some filtering and want to check back in with the original data.\nThis is called a *surrogate key*.\n\"\"\"\n\n\"\"\"\nA primary key and the corresponding foreign key in another table form a\nrelation. Relations are typically one-to-many. For example, each flight has\none plane, but each plane has many flights. In other data, you’ll occasionally\nsee a 1-to-1 relationship. You can think of this as a special case of\n1-to-many. You can model many-to-many relations with a many-to-1 relation\nplus a 1-to-many relation. For example, in this data there’s a many-to-many\nrelationship between airlines and airports: each airline flies to many airports;\neach airport hosts many airlines.\n\"\"\"\n\n#13.3.1 Exercises\n\n#Add a surrogate key to flights.\nglimpse(flights)\n\nflights2 <- flights %>%\n    mutate(flight_ref = row_number())\n\nglimpse(flights2)\n\n#Identify the keys in the following datasets\n\"\"\"\nLahman::Batting,\nbabynames::babynames\nnasaweather::atmos\nfueleconomy::vehicles\nggplot2::diamonds\n(You might need to install some packages and read some documentation.)\n\"\"\"\nlibrary(Lahman)\nglimpse(Batting)\n#playerID looks like primary key - can check:\nBatting %>%\n    count(playerID) %>%\n    filter(n > 1)\n#13665 rows with more than one entry unfortunately\nstr(Batting)\n?Batting\nBatting %>%\n    count(stint)\n\n#Draw a diagram illustrating the connections between the Batting, Master,\n#and Salaries tables in the Lahman package. Draw another diagram that shows\n#the relationship between Master, Managers, AwardsManagers.\n\n#How would you characterise the relationship between the Batting, Pitching,\n#and Fielding tables?\n\n\n# 13.4 mutating joins\n\"\"\"\nA mutating join allows you to combine variables from two tables. It first\nmatches observations by their keys, then copies across variables from one\ntable to the other.\n\"\"\"\n# Can shorten data set with lots of columns in order to see what's going\n# when new columns added - or use View from dplyr\n\nflights %>%\n    left_join(airlines, by = \"carrier\") %>%\n    View()\n\n#The result of joining airlines to flights2 is an additional variable: name.\n\n",
    "created" : 1493659889496.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "500716443",
    "id" : "92D02176",
    "lastKnownWriteTime" : 1493669969,
    "last_content_update" : 1493669969474,
    "path" : "~/Documents/Github/r4ds/r4ds_wrangle_relational.r",
    "project_path" : "r4ds_wrangle_relational.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}